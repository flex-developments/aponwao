package flex.aponwao.core.tsa;

import java.io.IOException;
import sun.security.pkcs.PKCS7;
import sun.security.util.DerValue;

public class TSResponse 
{
	 /*
	 * Se han reescrito parte de las clases de TSA de la maquina virtual porque tienen un error en la creacion de la request para el tsa
	 * Al crear el mensaje, si el algoritmo de hash no tiene parámetros (SHA1 por ejemplo), no añaden al campo parametro un NULL en ANS.1
	 * y el servidor TSA no es capaz de procesar correctamente la peticion (ZYLK), además no todos los tsa devuelven la cabecera 
	 * application/timestamp-response, algunos devuelven application/timestamp-reply con lo que la validación en base la cabecera
	 * también se ha modificado 
	 */

	/**
	 * The requested timestamp was granted.
	 */
	public static final int GRANTED = 0;

	public static final int GRANTED_WITH_MODS = 1;

	public static final int REJECTION = 2;

	public static final int WAITING = 3;
	public static final int REVOCATION_WARNING = 4;

	public static final int REVOCATION_NOTIFICATION = 5;
	public static final int BAD_ALG = 0;
	public static final int BAD_REQUEST = 2;
	public static final int BAD_DATA_FORMAT = 5;
	public static final int TIME_NOT_AVAILABLE = 14;
	public static final int UNACCEPTED_POLICY = 15;
	public static final int UNACCEPTED_EXTENSION = 16;
	public static final int ADD_INFO_NOT_AVAILABLE = 17;
	public static final int SYSTEM_FAILURE = 25;
	private static final boolean DEBUG = false;
	private int status;
	private String[] statusString = null;
	private int failureInfo = -1;
	private byte[] resbytes;
	

	private byte[] encodedTsToken = null;

	private PKCS7 tsToken = null;

	TSResponse(byte[] tsReply) throws IOException {
		resbytes = tsReply;
		parse(tsReply);
	}

	public int getStatusCode() {
		return status;
	}

	public String[] getStatusMessages() {
		return statusString;
	}

	public int getFailureCode() {
		return failureInfo;
	}

	public String getStatusCodeAsText() {

		switch (status) {
		case GRANTED:
			return "the timestamp request was granted.";

		case GRANTED_WITH_MODS:
			return "the timestamp request was granted with some modifications.";

		case REJECTION:
			return "the timestamp request was rejected.";

		case WAITING:
			return "the timestamp request has not yet been processed.";

		case REVOCATION_WARNING:
			return "warning: a certificate revocation is imminent.";

		case REVOCATION_NOTIFICATION:
			return "notification: a certificate revocation has occurred.";

		default:
			return ("unknown status code " + status + ".");
		}
	}

	public String getFailureCodeAsText() {

		if (failureInfo == -1) {
			return null;
		}

		switch (failureInfo) {

		case BAD_ALG:
			return "Unrecognized or unsupported alrorithm identifier.";

		case BAD_REQUEST:
			return "The requested transaction is not permitted or supported.";

		case BAD_DATA_FORMAT:
			return "The data submitted has the wrong format.";

		case TIME_NOT_AVAILABLE:
			return "The TSA's time source is not available.";

		case UNACCEPTED_POLICY:
			return "The requested TSA policy is not supported by the TSA.";

		case UNACCEPTED_EXTENSION:
			return "The requested extension is not supported by the TSA.";

		case ADD_INFO_NOT_AVAILABLE:
			return "The additional information requested could not be "
					+ "understood or is not available.";

		case SYSTEM_FAILURE:
			return "The request cannot be handled due to system failure.";

		default:
			return ("unknown status code " + status);
		}
	}

	public PKCS7 getToken() {
		return tsToken;
	}

	public byte[] getEncodedToken() {
		return encodedTsToken;
	}

	private void parse(byte[] tsReply) throws IOException {
		
		DerValue derValue = new DerValue(tsReply);
		
		
		if (derValue.tag != DerValue.tag_Sequence) {
			throw new IOException("Bad encoding for timestamp response");
		}

		// Parse status

		DerValue status = derValue.data.getDerValue();
		// Parse status
		this.status = status.data.getInteger();
		if (DEBUG) {
			System.out.println("timestamp response: status=" + this.status);
		}
		// Parse statusString, if present
		if (status.data.available() > 0) {
			DerValue[] strings = status.data.getSequence(1);
			statusString = new String[strings.length];
			for (int i = 0; i < strings.length; i++) {
				statusString[i] = strings[i].data.getUTF8String();
			}
		}
		// Parse failInfo, if present
		if (status.data.available() > 0) {
			byte[] failInfo = status.data.getBitString();
			int failureInfo = (new Byte(failInfo[0])).intValue();
			if (failureInfo < 0 || failureInfo > 25 || failInfo.length != 1) {
				throw new IOException("Bad encoding for timestamp response: "
						+ "unrecognized value for the failInfo element");
			}
			this.failureInfo = failureInfo;
		}

		// Parse timeStampToken, if present
		if (derValue.data.available() > 0) {
			DerValue timestampToken = derValue.data.getDerValue();
			encodedTsToken = timestampToken.toByteArray();
			tsToken = new PKCS7(encodedTsToken);
		}

		// Check the format of the timestamp response
		if (this.status == 0 || this.status == 1) {
			if (tsToken == null) {
				throw new TimestampException(
						"Bad encoding for timestamp response: "
								+ "expected a timeStampToken element to be present");
			}
		} else if (tsToken != null) {
			throw new TimestampException(
					"Bad encoding for timestamp response: "
							+ "expected no timeStampToken element to be present");
		}
	}

	final static class TimestampException extends IOException {
		TimestampException(String message) {
			super(message);
		}
	}

	public byte[] getResbytes() {
		return resbytes;
	}

	public void setResbytes(byte[] resbytes) {
		this.resbytes = resbytes;
	}
}
